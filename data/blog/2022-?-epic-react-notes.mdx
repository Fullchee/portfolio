---
title: "Epic React Insights"
date: "2021-12-25"
summary: "Notes and Insights from Epic React"
---

- [Exercises to redo](#exercises-to-redo)
- [React Fundamentals](#react-fundamentals)
  - [PropTypes](#proptypes)
- [React Hooks](#react-hooks)
  - [useState](#usestate)
  - [useEffect](#useeffect)
  - [Error Boundaries](#error-boundaries)
- [Advanced React Hooks](#advanced-react-hooks)
  - [useReducer](#usereducer)
  - [useCallback and useMemo](#usecallback-and-usememo)
    - [useCallback: custom hooks](#usecallback-custom-hooks)
    - [safeDispatch (safe fetch) and useEffect cleanup](#safedispatch-safe-fetch-and-useeffect-cleanup)
      - [How do you know if a component has been unmounted?](#how-do-you-know-if-a-component-has-been-unmounted)
  - [`useContext`](#usecontext)
    - [`useCount` wrapper for better errors](#usecount-wrapper-for-better-errors)
  - [`useEffect` vs `useLayoutEffect`](#useeffect-vs-uselayouteffect)
  - [`useImperativeHandle` ???????](#useimperativehandle-)
    - [`React.forwardRef`](#reactforwardref)
    - [Do you need to always use `useImperativeHandle` when using `React.forwardRef`?](#do-you-need-to-always-use-useimperativehandle-when-using-reactforwardref)
  - [`useDebugValue`](#usedebugvalue)
- [Advanced React Patterns](#advanced-react-patterns)
  - [Context Module Pattern](#context-module-pattern)
    - [Why can't we just put the function in the `useCount` accessor?](#why-cant-we-just-put-the-function-in-the-usecount-accessor)
  - [Compound components](#compound-components)
    - [Why do we need to `cloneElement`?](#why-do-we-need-to-cloneelement)
    - [How do you know if a component is React or a vanilla DOM element?](#how-do-you-know-if-a-component-is-react-or-a-vanilla-dom-element)
  - [Prop Collections & Getters](#prop-collections--getters)
  - [State Reducer](#state-reducer)
    - [Why is it called State reducer?](#why-is-it-called-state-reducer)
    - [What does the `={}` do?](#what-does-the--do)
  - [Control Props](#control-props)

## Exercises to redo

- advanced-react-hooks
  - useCallback custom hooks (02.0.js)
-

## React Fundamentals

1. `React.createElement` is like `document.createElement()`
2. `document.append(element)` is like `ReactDOM.render(reactComponent, document.body)`
   1. ReactDOM because react can be rendered in many environments (example: React Native)

If you only want the second value in an array, you can just use an array

```js
[count, setCount];
```

```js
[, setCount];
```

### PropTypes

I got a bit confused when I got to creating custom components extra credit where I'm not sure how React is calling the `propTypes` that we defined (not from the library).

- [Course video link](https://epicreact.dev/modules/react-fundamentals/creating-custom-components-extra-credit-solution-03)
- [Link to code](https://github.com/kentcdodds/react-fundamentals/blob/main/src/final/04.extra-3.html)

I broke it down in this StackOverflow question where I even tried looking at the `React` source code but I didn't explain my question clearly enough because the one response gave a link to the `propTypes`.

(which is interesting but not exactly what I'm looking for ðŸ˜…)

https://stackoverflow.com/questions/70477035/when-are-the-props-propname-and-componentname-passed-to-the-proptypes-func

I'm also posted on KCD's discord and I'm likely going to go to his office hours next Monday

## React Hooks

### useState

- can accept a function which is a lazy initializer!
- if you just want to calculate the initial state once (digits of pi)

### useEffect

- `fetch`: forgot to return early if pokemonName is null
- I forgot about having a status variable
  - helps with determining what to display
  - https://kentcdodds.com/blog/stop-using-isloading-booleans
- the way that Kent does a sort of manual TDD where he always gets something to display
  - eg: create a variable with a stub error message to make sure that the error shows up

### Error Boundaries

- can take in a `FallbackComponent` arg
- Problem with using the `key` prop for the error boundary
  - it'll mount and unmount every time the `key` is updated
  - flashing
- we can pass `resetErrorBoundary` prop that gets triggered in the `FallbackComponent`
- `resetKeys` prop works as well

## Advanced React Hooks

Custom hooks are just regular functions that happen to have side effects!

They can return anything

### useReducer

```js
const [state, dispatch] = useReducer(state, action);
```

- it doesn't have to follow the Redux style of having actions with a `type` prop
- first prop: the old state
- second prop: whatever you pass to `dispatch`

### useCallback and useMemo

Use cases (https://kentcdodds.com/blog/usememo-and-usecallback)

1. not have a function re-render every time so that it can be used in a useEffect dep array
2. avoiding unnecessary re-renders when re-rendering is super expensive (Graphs, Charts, Animations)
3. `useMemo` can be passed a function (just like `useState`) and lazily calculate computationally expensive items

#### useCallback: custom hooks

- I had trouble with the middle param of what the initial state should be
- I autofilled the dependencies and got into an infinite render loop

#### safeDispatch (safe fetch) and useEffect cleanup

- Memory leak when unmounting before the `fetch` finishes
- it's not a class component so we can't just have a `componentWillMount` and abort the `fetch`
- I have to cancel subscriptions and async tasks in the useEffect cleanup function

##### How do you know if a component has been unmounted?

1. create a `useEffect`
2. Set the dependencies to be `[]` (so it only gets called once)
3. callback: sets a `ref` to be true
4. cleanup function sets the `ref` to be false

- https://github.com/helderburato/use-is-mounted-ref/blob/main/src/use-is-mounted-ref.ts

### `useContext`

- Always give your contexts a `display name`
  - `ToggleContext.displayName = 'ToggleContext'`
  - shows up in the browser dev tools
- creating a `CountProvider` component wrapper
  - so that it can have its own state and hooks to manage the state
  - instead of directly using `<ToggleContext.Provider value={{count, setCount}}>...</...>`
- you can pass `count` and `setCount` as the value of the Provider

#### `useCount` wrapper for better errors

```js
const value = React.useContext(CountContext);
if (!value) {
  throw new Error("useState must be within the CountContext");
}
return value;
```

### `useEffect` vs `useLayoutEffect`

- same API
- useEffect is run after pixels are painted
- useLayoutEffect is run before so it will delay painting
  - can update the DOM before it paints

### `useImperativeHandle` ???????

#### `React.forwardRef`

- can pass a `ref` as a second param
  - instead of the first param with all the other regular props

**Could you put `ref` as a prop? in the first param of the component?**

- yeah but that would cause a re-render
- you might not want to always re-render when the ref that's passed down to the component changes

#### Do you need to always use `useImperativeHandle` when using `React.forwardRef`?

### `useDebugValue`

- feels like `__repr__` in Python for custom hooks

## Advanced React Patterns

### Context Module Pattern

- when creating a `Context` + `useReducer`
- if you have common dispatches you want to share
  - just export it from the `counter.js` alongside the `CountProvider` and `useCount`

```js
export { UserProvider, useUser, updateUser };
```

#### Why can't we just put the function in the `useCount` accessor?

- we'd have to add `useCallback` to each function because we'd be putting it in the Provider's `value`
- won't be able to tree shake (only get the functions we use)
  - every function would have a `useCallback` because they'd need to be in the dependency array
- can't lazy load

### Compound components

- like `Table` and `Column`
- where `Column` expects a bunch of props from `Table`
  - but we don't set it explicitly

```js
<Table>
  {/* `Table` gives `Column` some props behind the scenes */}
  <Column />
  <Column />
  <Column />
</Table>
```

#### Why do we need to `cloneElement`?

- state is handled by the parent component
- we need to clone because we can't modify props directly
  - like creating a new copy of array
- we only want to use `cloneElement` on react components
- Flexible Compound Components uses `Context` so that it can pass to any descendant
  - so we don't need `cloneElement`

#### How do you know if a component is React or a vanilla DOM element?

```
typeof child.type === 'string' // DOM
```

#### Flexible Compound Components

- instead of passing props via `cloneElement`
- we pass down data via `Context` and `useContext`

### Prop Collections & Getters

Why

- less duplication
  - get the shared props
- example of props to be returned `{'aria-pressed': on, onClick: toggle}`

```js
function useToggle() {
  const [on, setOn] = React.useState(false);
  const toggle = () => setOn(!on);

  function getTogglerProps({ onClick, ...props } = {}) {
    return {
      "aria-pressed": on,
      onClick: callAll(onClick, toggle),
      ...props,
    };
  }

  return {
    on,
    toggle,
    getTogglerProps,
  };
}
```

**Usage**

```js
<Switch {...getTogglerProps({on})} />
<button
  {...getTogglerProps({
    'aria-label': 'custom-button',
    onClick: () => console.info('onButtonClick'),
    id: 'custom-button-id',
  })}
>
```

### State Reducer

- let the user of the hook pass in their own reducer
  - inversion of control!
- to avoid duplication, we can do this to just update one case

```js
function toggleStateReducer(state, action) {
  if (action.type === "toggle" && clickedTooMuch) {
    return { on: state.on };
  }
  return toggleReducer(state, action); // default hook reducer
}
```

#### Why is it called State reducer?

- you pass in a reducer that modifies the state

#### What does the `={}` do?

```js
// useToggle() will work
function useToggle({initialOn = false} = {}) {...}
```

vs

```js
// useToggle() will result in an error
function useToggle({initialOn = false}) {
```

### Control Props

- ![Control Props](/assets/images/blog/sources-tab.png)
- replicating what React does to forms (controlled vs uncontrolled)
  - is there a value that tha sh
- error when going from uncontrolled to controlled (or vice versa)
  - example: giving React a value and then later assigning it


#### Why is it controlled if `controlledOn` != null?
